#!/usr/bin/env bash

# The Cloud Foundry Python Buildpack. This script accepts parameters for a build
# directory, a cache directory, and a directory for app environment variables.

# Usage:
#
#     $ bin/finalize <build-dir> <cache-dir> <deps_dir> <deps_index> 

# Fail fast and fail hard.
set -eo pipefail

[ "$BUILDPACK_XTRACE" ] && set -o xtrace

# Prepend proper path for virtualenv hackery. This will be deprecated soon.
export PATH=:/usr/local/bin:$PATH

# Paths.
BIN_DIR=$(cd $(dirname $0); pwd) # absolute path
ROOT_DIR=$(dirname $BIN_DIR)
BUILD_DIR=$1
CACHE_DIR=$2
DEPS_DIR=$3
DEPS_IDX=$4
export BIN_DIR BUILD_DIR CACHE_DIR DEPS_DIR DEPS_IDX

# CF Common
BUILDPACK_PATH=$ROOT_DIR
export BUILDPACK_PATH
source $ROOT_DIR/compile-extensions/lib/common
$ROOT_DIR/compile-extensions/bin/check_buildpack_version $ROOT_DIR $CACHE_DIR

if [ -n "$DEPS_DIR" ]; then
  env_vars=$($BUILDPACK_PATH/compile-extensions/bin/build_path_from_supply $DEPS_DIR)
  for env_var in $env_vars; do
    export $env_var
  done
  $BUILDPACK_PATH/compile-extensions/bin/write_profiled_from_supply $DEPS_DIR $BUILD_DIR
fi
# END CF Common

# Syntax sugar.
source $BIN_DIR/utils

# # Use miniconda if environment.yml exists and exit
# if [ -f $BUILD_DIR/environment.yml ]; then
#   echo "----------------- USING CONDA BUILDPACK -----------------"

#   # Experimental pre_compile hook.
#   pushd $BUILD_DIR
#     source $BIN_DIR/steps/hooks/pre_compile
#   popd

#   $BIN_DIR/steps/conda-install $BUILD_DIR $CACHE_DIR
#   $ROOT_DIR/compile-extensions/bin/store_buildpack_metadata $ROOT_DIR $CACHE_DIR

#   # Experimental post_compile hook.
#   pushd $BUILD_DIR
#     source $BIN_DIR/steps/hooks/post_compile
#   popd

#   exit 0
# fi

# we need to put a bunch of symlinks in there later
mkdir -p /app/.cloudfoundry

# Switch to the repo's context.
cd $BUILD_DIR

# # Uninstall removed dependencies with Pip.
# source $BIN_DIR/steps/pip-uninstall
echo "------------------------------------------------------------------------ $PKG_CONFIG_PATH"
# Install dependencies with Pip (where the magic happens).
source $BIN_DIR/steps/pip-install

# # Support for NLTK corpora.
# sub-env $BIN_DIR/steps/nltk

# # Support for pip install -e.
# rm -fr $BUILD_DIR/.cloudfoundry/src
# deep-cp /app/.cloudfoundry/src $BUILD_DIR/.cloudfoundry/src

# # Django collectstatic support.
# sub-env $BIN_DIR/steps/collectstatic

# Create .profile script for application runtime environment variables.
# set-env PATH '$HOME/.cloudfoundry/python/bin:$PATH'
# set-env PYTHONUNBUFFERED true
# set-env PYTHONHOME /app/.cloudfoundry/python
# set-env LIBRARY_PATH '/app/.cloudfoundry/vendor/lib:/app/.cloudfoundry/python/lib:$LIBRARY_PATH'
# set-env LD_LIBRARY_PATH '/app/.cloudfoundry/vendor/lib:/app/.cloudfoundry/python/lib:$LD_LIBRARY_PATH'
# set-default-env LANG en_US.UTF-8
# set-default-env PYTHONHASHSEED random
# set-default-env PYTHONPATH /app/

# Experimental post_compile hook.
source $BIN_DIR/steps/hooks/post_compile

# set +e
# # rewrite build dir in egg links to /app so things are found at runtime
# find .cloudfoundry/python/lib/python*/site-packages/ -name "*.pth" -print0 2> /dev/null | xargs -r -0 -n 1 sed -i -e "s#$(pwd)#/app#" &> /dev/null
# set -e

# set +e
# # Support for PyPy
# find .cloudfoundry/python/lib-python/*/site-packages/  -name "*.pth" -print0 2> /dev/null | xargs -r -0 -n 1 sed -i -e "s#$(pwd)#/app#" &> /dev/null
# set -e

# Fin.
$ROOT_DIR/compile-extensions/bin/store_buildpack_metadata $ROOT_DIR $CACHE_DIR
